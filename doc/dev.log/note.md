# Ruler-Decorators 设计构想与辩证笔记

## 核心设计理念

### 1. 多模式拦截系统

**两种基础驱动模式：**

-   **访问器模式 (Accessor)**: 传统 getter/setter，简单直接，兼容性好
-   **代理模式 (Proxy)**: 现代 Proxy API，功能强大，拦截全面

**四种细分类别：**

1. **accessor**: 基础访问器模式，适用于简单属性拦截
2. **function-param-accessor**: 专门针对函数参数的特殊访问器
3. **property-proxy**: 属性级代理，精确控制特定属性
4. **class-proxy**: 类级代理，全面拦截所有属性访问

### 2. 统一的存储架构

**设计目标：** 将零散的 WeakMap 统一到单一的 Storage 系统中

**实现方案：**

-   使用单个 `Storage` WeakMap 管理所有装饰器元数据
-   `rd_descriptor` 类型包含所有模式所需字段
-   提供统一的 API 接口进行描述符操作

### 3. 装饰器装载系统

**装饰器类型与模式对应关系：**

-   **ClassDecorator**:

    -   class-proxy (默认/显式)
    -   accessor (配置回退)

-   **PropertyDecorator**:

    -   property-proxy (显式配置)
    -   accessor (默认/显式配置)

-   **MethodDecorator**:

    -   function-param-accessor (默认)
    -   accessor (理论可行，但需谨慎)

-   **ParameterDecorator**:
    -   待标准完善

## 辩证思考

### 优势分析

1. **灵活性**: 多种模式满足不同场景需求
2. **统一性**: 单一 Storage 系统简化了架构复杂度
3. **扩展性**: rd_descriptor 设计便于未来功能扩展
4. **兼容性**: 支持传统环境和现代环境

### 挑战与考量

1. **模式选择的复杂性**: 四种模式可能让使用者困惑
2. **性能考量**: Proxy 模式虽然强大但有性能开销
3. **类型安全**: 需要确保不同装饰器类型的正确使用
4. **错误处理**: 需要完善的错误提示机制

### 设计决策

1. **选择 WeakMap**: 避免内存泄漏，自动垃圾回收
2. **统一描述符**: 简化数据结构，便于维护
3. **模式自动选择**: 根据环境和配置智能选择最佳模式
4. **显式配置**: 提供装饰器让用户可以显式控制模式

## 未来展望

1. **参数装饰器支持**: 等待 TypeScript 标准完善
2. **性能优化**: 进一步优化 Proxy 模式的性能
3. **工具链完善**: 开发调试工具和性能分析工具
4. **生态系统**: 构建基于此库的规则生态系统

## 核心价值

这个库的核心价值在于提供了一个统一、灵活、强大的属性装饰框架，既保持了传统方式的简单性，又提供了现代 Proxy 的强大功能，让开发者可以根据具体需求选择最适合的拦截模式。
