# 1.0.0.1st 第一版介绍

| 模式                    | 支持度 | 评价       | 现状                                                                 |
| ----------------------- | ------ | ---------- | -------------------------------------------------------------------- |
| Accessor                | 100%   | `夯`       | 百分百支持，大概没什么问题                                           |
| Function-Param-Accessor | 100%   | `人上人`   | 十分强大，你可以统一处理（一条处理链），也可以针对特定参数制定处理链 |
| ~~Property-Proxy~~      | 0%     | **`废物`** | 难写的要死，而且没有头绪了                                           |
| Class-Proxy             | 20%    | `npc`      | 除了替代几个驱动函数以外没什么用处                                   |

Assessor 模式现在已经是完全支持，即拿即用十分方便  
Function-Param-Accessor 有两种句柄写法

一种是`paramFilterHandler[]`

```ts
Filter[]
```

统一处理所有参数

另一种是`paramFilterChainHandler[]`（`ParamRejectHandlerChain`模式）

```ts
[
    // param 1
    Filter[],
    [],
    // param 3
    Filter[]
]
```

针对某几个参数处理

Property-Proxy 原来我打算是给数组用的  
不过我要写他的话还得再定制一套函数  
现在的函数已经是太多了，我懒得再写几个  
不但不好维护，我后面还得想办法解决参数的问题  
你知道的，看着那一堆 reduces 都感觉让人头大，参数能传巨多，我后面还得想办法给他打包成几个对象

这个模式是个逻辑好像还不能完全和 assessor 模式兼容，  
因为在 str 那边多了一个 key 参数，原版 assessor 没有  
后期我要想办法让` $setter``$getter `能完全支持两种模式

Class-Proxy 我不知道有什么用，但它最大的用处也就可能是优化吧  
现在的版本里面已经有自动启用 Class-Proxy 的逻辑  
目的就是减少内存开销，你不可能给一万个属性都添加驱动函数吧  
（虽然还没有这种情况（

在后续的维护里我得把这一些高度重合的逻辑给它缩成一个统一的逻辑，  
那些规则还可以跨模式使用  
还得去除矢山逻辑

目前看这个库感觉够重的.......
