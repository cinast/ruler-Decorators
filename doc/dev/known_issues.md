# Known Issues & Technical Limitations

## 已解决的问题

1. ~~一次只能给属性加上控制，不能给属性的属性加上监控~~

    - ✅ 已通过 Property-Proxy 和 Class-Proxy 模式解决

2. ~~类代理模式下值处理不正确~~

    - ✅ 已修复 proxy trap 中的处理对象解析

3. ~~函数参数访问器无效~~

    - ✅ 已修复装饰器类型识别和参数处理逻辑

4. ~~条件装饰器返回处理对象而不是值~~
    - ✅ 已修复处理对象的值提取逻辑

## 当前限制

1. **类型传递问题**

    - 复杂的泛型类型推断在某些情况下可能不够精确
    - 建议在使用时明确指定类型参数

2. **性能考虑**

    - 大量使用 WeakMap 和 reduce 可能影响性能
    - 对于高性能场景，建议谨慎使用复杂规则链

3. **浏览器兼容性**

    - 依赖 Proxy API，在不支持 Proxy 的环境中等效于 accessor 模式
    - 需要 ES6+ 环境

4. **调试复杂性**

    - 复杂的规则链可能增加调试难度
    - 建议使用 debugLogger 进行调试

5. **模式混合限制**
    - 不支持同时使用多种驱动模式
    - 类代理模式会覆盖其他模式的设置
      [file content end]

## [file name]: notice.md

[file content begin]

# 重要注意事项

## $$init 初始化函数

`@$$init()` 装饰器用于自动布置驱动函数对或代理，并注册句柄。

## 驱动模式 & 操作拦截模式

### 可用模式：

1. **accessor** (默认)

    - 传统的 getter/setter 模式
    - 值存储在闭包或 valueStorage 中

2. **proxy**

    - 代理模式，包含：
        - **class-proxy**: 监控整个对象
        - **property-proxy**: 监控特定属性

3. **function-param-accessor**
    - 专门处理函数参数的模式

## 使用建议

### 1. 值访问注意事项

-   永远不要使用 `target[key]` 直接访问属性
-   使用处理器提供的 `value` 参数
-   直接访问可能导致调用栈溢出或性能问题

### 2. 类型安全

-   装饰器中的类型检查受限
-   建议在使用时明确指定类型参数
-   复杂的泛型推断可能不精确

### 3. 描述符限制

-   描述符有 `get/set` 就没有 `value`（ES 规范）
-   避免在属性描述符中使用 `this`
-   属性可能刚定义，没有描述符

### 4. 模式选择

-   不要混合使用不同模式
-   类代理模式会覆盖其他模式的设置
-   选择适合场景的模式：
    -   简单属性：accessor 模式
    -   复杂对象/数组：property-proxy 模式
    -   全对象监控：class-proxy 模式
    -   方法参数处理：function-param-accessor 模式

### 5. 性能考虑

-   避免过长的处理链
-   对于性能敏感的场景，测试不同模式的性能影响
-   考虑使用 \_\_Setting 进行优化配置

### 6. 调试建议

-   使用 `debugLogger` 进行调试
-   在复杂规则中添加日志点
-   利用 `valueRecorder` 进行值变化跟踪

## 常见问题解决

1. **处理器返回处理对象而不是值**

    - 确保在 proxy trap 中正确提取 `output` 值

2. **函数参数处理器不生效**

    - 检查装饰器类型识别是否正确
    - 确保参数处理器正确处理 `prevResult`

3. **值存储不正确**

    - 检查 valueStorage 的初始化
    - 确保正确访问实例特定的存储

4. **类代理模式无效**
    - 检查 `managedByClassProxy` 标记是否正确设置
    - 确保 proxy trap 正确处理处理器返回值
