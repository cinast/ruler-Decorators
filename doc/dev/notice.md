# **重要注意事项**

1. **manage.ts 内一律不准用原型去找描述符**
2. **$$init 内除了涉及 class 的逻辑，其他凡是在普通 descriptor 内使用 this 的都会造成严重后果！**  
   **请用 target 代之。**

—— **_违者，斩！_**

---

## $$init 初始化函数

`@$$init()` 装饰器用于自动布置驱动函数对或代理，并注册句柄。

## 驱动模式 & 操作拦截模式

### 可用模式：

1.  **accessor** (默认)

    -   传统的 getter/setter 模式
    -   值存储在闭包或 valueStorage 中

2.  **proxy**

    -   代理模式，包含：
        -   **class-proxy**: 监控整个对象
        -   **property-proxy**: 监控特定属性  
            ⚠️ 由于技术限制，需要在 class 头顶加@$$init()  
            实际上这个模式是由 cls-proxy 驱动的

3.  **function-param-accessor**

    -   专门处理函数参数的模式

## 使用建议

### 1. 值访问注意事项

-   永远不要使用 `target[key]` 直接访问属性
-   使用处理器提供的 `value` 参数
-   直接访问可能导致调用栈溢出或性能问题

### 2. 类型安全

-   装饰器中的类型检查受限
-   建议在使用时明确指定类型参数
-   复杂的泛型推断可能不精确

### 3. 描述符限制

-   描述符有 `get/set` 就没有 `value`（ES 规范）
-   避免在属性描述符中使用 `this`
-   属性可能刚定义，没有描述符

### 4. 模式选择

-   不要混合使用不同模式
-   类代理模式会覆盖其他模式的设置
-   选择适合场景的模式：
    -   简单属性：accessor 模式
    -   复杂对象/数组：property-proxy 模式
    -   全对象监控：class-proxy 模式
    -   方法参数处理：function-param-accessor 模式

### 5. 性能考虑

-   避免过长的处理链
-   对于性能敏感的场景，测试不同模式的性能影响
-   考虑使用 \_\_Setting 进行优化配置

### 6. 调试建议

-   使用 `debugLogger` 进行调试
-   在复杂规则中添加日志点
-   利用 `valueRecorder` 进行值变化跟踪

## 常见问题解决

1.  **处理器返回处理对象而不是值**

    -   一定是调用链上游有 cs 把 `lastResult` 之类的参数直接或间接返回了
    -   确保在 proxy trap 中正确提取 `output` 值
    -   如果没办法：自己提出来吧（无奈

2.  **规则句柄没效果或者干了点奇怪的事情**

    -   往上游走，

        0. 在你的句柄上加 log 函数，没有输出，看`1`
        1. 在 [`manage.ts`](../../src/manage.ts) 的 `applyXXX` 函数插 logger  
           在这地方获取描述符
            - 如果有描述符，没有句柄，看`2`
            - 如果没有描述符，看`4`
        2. 在 `addXXX`函数插 logger  
           在这地方看你的句柄，等他设置之后再回来 get 一遍，再看设置的结果
        3. 去你用的 函数工厂 `callResult` 和 `rejectResult`**返回的`if`前** 插 logger
            - 如果如果答案不是你想要的
              去那条规则句柄上面找，给它每一个环节的调用都加入 logger
            - 如果发现了处理对象套着处理对象
              参见`1`号问题
        4. 去 `$$init` 到处插 logger  
           先检查 rd 描述符 的注册情况  
           再去对应模式的 case 那边插入（那个语句块是处理的核心）  
           （到这一步大概是因为你用了新创的模式）  
           （或者是因为我漏逻辑了）

3.  **函数参数处理器不生效**

    -   检查装饰器类型识别是否正确
    -   确保参数处理器正确处理 `prevResult`

4.  **值存储不正确**

    -   检查 valueStorage 的初始化
    -   确保正确访问实例特定的存储

5.  **类代理模式无效**

    -   检查 `managedByClassProxy` 标记是否正确设置
    -   确保 proxy trap 正确处理处理器返回值

n. 也有可能是 reduce 调用时忘加初始值
